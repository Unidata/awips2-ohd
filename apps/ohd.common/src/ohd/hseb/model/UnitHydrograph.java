/*
 * Created on Jun 25, 2003
 *
 * This class is designed to compute the flow from runoff.
 */
package ohd.hseb.model;

import java.util.*;

import ohd.hseb.measurement.*;


/**
 * @author Chip Gobs
 *
 * The UnitHydrograph class maps runoff to the amount of marginal flow 
 * generated by that runoff.  
 * It returns a RegularTimeSeries object that contains flow measurements.
 */



public class UnitHydrograph
{
	
 
    //input:   inches of runoff
    //a starting time
    //output: a time series of flow in CFS

	private static final long MILLIS_PER_HOUR = 1000 * 60 * 60;
    
    private MeasuringUnit _measuringUnit = MeasuringUnit.cfs;
   
    private String _locationId = null;
    private String _areaId = null;
    private String _rainfallRunoffModelTypeName = null;
    
    private int _interval = -1; // in hours
    
	private List _measurementList = new ArrayList();
   
	//----------------------------------------------------------------------
    
    
    public UnitHydrograph(MeasuringUnit measuringUnit, int intervalInHours)
    {
    	_measuringUnit = measuringUnit;
        _interval = intervalInHours;
    }
  
	//----------------------------------------------------------------------
  
    
	public void setMeasuringUnit(MeasuringUnit measuringUnit)
	{
		_measuringUnit = measuringUnit;
	}
    //----------------------------------------------------------------------
 
	public MeasuringUnit getMeasuringUnit()
	{
		return _measuringUnit;
	}
    //----------------------------------------------------------------------
 
	public void setLocationId(String locationId)
	{
		_locationId = locationId;
	}
    //----------------------------------------------------------------------
 
	public String getLocationId()
	{
		return _locationId;
	}
    //----------------------------------------------------------------------
 
	public void setAreaId(String areaId)
	{
		_areaId = areaId;
	}
    //----------------------------------------------------------------------
 
	public String getAreaId()
	{
		return _areaId;
	}    
    //----------------------------------------------------------------------
    
    public int getOrdinateCount()
    {
        return _measurementList.size();    
    }
    //----------------------------------------------------------------------
    
    public List getMeasurementList()
    {
        return _measurementList;    
    }
    
	//----------------------------------------------------------------------
      
    public void addMeasurement(RelTimeMeasurement origMeasurement)
    {
    	RelTimeMeasurement newMeasurement = 
                (RelTimeMeasurement) origMeasurement.getConvertedCopy(_measuringUnit);
        
        _measurementList.add(newMeasurement);
    
        return;
    }
    
    //  ----------------------------------------------------------------------
    
    public void setInterval(int interval)
    {
        _interval = interval;	
    }
  
    //----------------------------------------------------------------------
   
    public int getIntervalInHours()
    {
           return _interval;    
    }

	//----------------------------------------------------------------------
   
    public static UnitHydrograph getTestUnitHydrograph()
    {
		double[] valueArray = { 100.0, 200.0, 350.0, 500.0, 
								300.0, 250.0, 200.0, 150.0, 
								100.0, 50.0, 25.0, 10};	
    
    	UnitHydrograph uhg = new UnitHydrograph(MeasuringUnit.cfs, 1);
		
    	
    	for (int i = 0; i < valueArray.length; i++)
    	{
    		RelTimeMeasurement measurement = new RelTimeMeasurement(valueArray[i], i, MeasuringUnit.cfs);
    		uhg.addMeasurement(measurement); 
    	}
    	
    	return uhg;
    	
    }
    
    //----------------------------------------------------------------------
    public UnitHydrograph getScaledUnitHydrograph(double newTotalDischarge)
    {
      
        UnitHydrograph uhg = new UnitHydrograph(this.getMeasuringUnit(), this.getIntervalInHours());
        
        double totalDischarge = this.getTotalDischarge();
        double scalingFactor = newTotalDischarge/totalDischarge;
        
        for (int i = 0; i < _measurementList.size(); i++)
        { 
            RelTimeMeasurement measurement = (RelTimeMeasurement) _measurementList.get(i); 
           
            double value = measurement.getValue() * scalingFactor;
                  
            RelTimeMeasurement newMeasurement = new RelTimeMeasurement(measurement);
            newMeasurement.setValue(value);
                  
            uhg.addMeasurement(newMeasurement); 
        }
        
       
        return uhg;
        
    }
    
    //----------------------------------------------------------------------
    
    public RelTimeMeasurement getPeakFlowMeasurement()
    {
        RelTimeMeasurement peak = null;
        
         for (int i = 0; i < _measurementList.size() ; i++)
         {
             RelTimeMeasurement measurement = (RelTimeMeasurement) _measurementList.get(i);    
             if  ( (peak == null) || 
                   (measurement.getValue() > peak.getValue())
                 )
             {
                 peak = measurement;    
             }  
         }
    
         return peak;         
    }
    
    //----------------------------------------------------------------------
    
    public IrregularTimeSeries getFlowTimeSeries(AbsTimeMeasurement runoffMeasurement)
    {
       MeasuringUnit runoffUnit = MeasuringUnit.inches;
       MeasuringUnit dischargeUnit = MeasuringUnit.cfs;
            
       //convert to inches
       AbsTimeMeasurement convertedRunoffMeasurement = 
                 AbsTimeMeasurement.getConvertedCopy(runoffMeasurement, runoffUnit);
       
       double scaleFactor = convertedRunoffMeasurement.getValue();
    	
    	
	   IrregularTimeSeries ts = new IrregularTimeSeries(MeasuringUnit.cfs);
       
       long startTime = runoffMeasurement.getTime();
       long measurementTime = 0;
       double discharge = 0.0;
       
       for (int i = 0; i < _measurementList.size(); i++)
       {
       	   measurementTime = startTime + (i)*(MILLIS_PER_HOUR); 
       	   
       	   Measurement unitGraphValue = 
       	               (Measurement) _measurementList.get(i);
       	   
       	   discharge = scaleFactor * unitGraphValue.getValue();
       	   AbsTimeMeasurement newMeasurement = new AbsTimeMeasurement(discharge,
       	                                                measurementTime,
       	                                                dischargeUnit);
           ts.insertMeasurement(newMeasurement);
       }
       
       return ts;       	
    }
    
    //----------------------------------------------------------------------
 
    public RegularTimeSeries getFlowRegularTimeSeries(AbsTimeMeasurement runoffMeasurement)
    {
        MeasuringUnit runoffUnit = MeasuringUnit.inches;
        MeasuringUnit dischargeUnit = MeasuringUnit.cfs;
            
        //convert to inches
        AbsTimeMeasurement convertedRunoffMeasurement = 
                    AbsTimeMeasurement.getConvertedCopy(runoffMeasurement, runoffUnit);
       
        double scaleFactor = convertedRunoffMeasurement.getValue();
        
        int hourCount = _measurementList.size();
        int intervalInHours = 1;
        
        long intervalInMillis = intervalInHours * MILLIS_PER_HOUR;
        
        long startTime = runoffMeasurement.getTime();
        long endTime = startTime + ((hourCount-1) * MILLIS_PER_HOUR);
        
        RegularTimeSeries ts = new RegularTimeSeries(startTime, endTime,
                                              intervalInHours, dischargeUnit);
       
       
        double discharge = 0.0;
       
        int i = 0;
        for (long time = startTime; time <= endTime; time += intervalInMillis)
        {
            
            Measurement unitgraphValue = 
                          (Measurement) _measurementList.get(i);
           
            discharge = scaleFactor * unitgraphValue.getValue();
            
            Measurement newMeasurement = new Measurement(discharge,
                                                         dischargeUnit);
                                                           
            ts.setMeasurementByTime(newMeasurement, time);
          
            i++;
        }
       
        return ts;        
       
    } //end getFlowRegularTimeSeries  
    
      //----------------------------------------------------------------------
 
    
    public String toString()
    {
    	String outString = null;
    	
    	StringBuffer buffer = new StringBuffer();
    	
    	for (int i = 0; i < _measurementList.size(); i++)
    	{
    	    Measurement m = (Measurement) _measurementList.get(i);
    	    buffer.append ("ordinal " + i + " = " + m.getValue() + "\n");	
    	}
    	
    	outString = buffer.toString();
    	
    	return outString;
    }
    
    //------------------------------------------------------------------------
    public double getTotalDischarge()
    {
        double total = 0.0;
        
        for(int i = 0; i < _measurementList.size(); i++)
        {
            RelTimeMeasurement measurement = (RelTimeMeasurement) _measurementList.get(i);
            total += measurement.getValue();
        }
        
        return total;
    }
    //------------------------------------------------------------------------
    
    public RegularTimeSeries calculateTotalDischargeTs(String status,
                                                  RegularTimeSeries interimFlowTimeSeries,
                                                  RegularTimeSeries runoffTs,
                                                  long startTime,
                                                  long endTime,
                                                  long intervalInMillis) 
                                                             
                                                             
       {
        
          //String header = "UnitHydrograph.calculateTotalDischargeTs(): " + status;
       
         // System.out.println(header);
       
          RegularTimeSeries unitgraphFlowTimeSeries = null;
          RegularTimeSeries totalFlowTimeSeries = interimFlowTimeSeries.copy();
       
           // convert the runoff to discharge through the unithydrograph                                                
          for (long time = startTime;  time <= endTime; time += intervalInMillis)
          {      
              Measurement runoffMeasurement = null;
           
              if (runoffTs != null)
              {
                  runoffMeasurement = runoffTs.getMeasurementByTime(time);
              }
              else
              {
                  //System.out.println(header + " runoffTs is null");    
              }
           
              if (runoffMeasurement == null)
              {
                 // System.out.println(header + " runoffMeasurement is null when time = " + 
                 //                   DbTimeHelper.getDateTimeStringFromLongTime(time));    
              }
    
              else
              {
                   
                  AbsTimeMeasurement absTimeRunoffMeasurement = 
                           new AbsTimeMeasurement(runoffMeasurement, time); 
                                                                          
                  unitgraphFlowTimeSeries = 
                          this.getFlowRegularTimeSeries(absTimeRunoffMeasurement);
                       
                       
                  if ( (totalFlowTimeSeries != null) && 
                       (unitgraphFlowTimeSeries != null) 
                      )
                  {        
                      totalFlowTimeSeries =
                           RegularTimeSeries.add(totalFlowTimeSeries, 
                                                 unitgraphFlowTimeSeries);
                                              
                    //  System.out.println(header + "unitgraphFlowTimeSeries is not null");
                   //   System.out.println(header + "interimFlowTimeSeries is not null\n");  
                  }
                  else if (unitgraphFlowTimeSeries != null)
                  {
                      totalFlowTimeSeries = unitgraphFlowTimeSeries.copy();
                   //   System.out.println(header + "unitgraphFlowTimeSeries is not null");
                   //   System.out.println(header + "interimFlowTimeSeries is null\n");       
                  }
               
              }                                        
          } //end for
       
          return totalFlowTimeSeries; 
       } 
//     ---------------------------------------------------------------------     
    
    public static void main(String[] args) throws Exception
    {
    	UnitHydrograph uhg = UnitHydrograph.getTestUnitHydrograph();
		AbsTimeMeasurement runoff = null;
    	IrregularTimeSeries ts1 = null;
		IrregularTimeSeries ts2 = null;
		IrregularTimeSeries ts3 = null;
    	
    	long desiredTime = new Date().getTime() ;
    	long roundingFactor = 1000 * 60 * 60;
    	desiredTime /= roundingFactor;
    	desiredTime *= roundingFactor;
    	
    	
    	
		runoff = new AbsTimeMeasurement(1.0, desiredTime, MeasuringUnit.inches);
    	ts1 = uhg.getFlowTimeSeries(runoff);	
    	System.out.println("ts1 = " + ts1);
    	
		runoff = new AbsTimeMeasurement(1.0, desiredTime + (1000 * 60 * 60), MeasuringUnit.inches);
		ts2 = uhg.getFlowTimeSeries(runoff);
		System.out.println("ts2 = " + ts2);
		
		ts3 = IrregularTimeSeries.add(ts1, ts2);
		System.out.println("ts3 = " + ts3);
    	 
    } //main

    /**
     * @param rainfallRunoffModel The rainfallRunoffModel to set.
     */
    public void setRainfallRunoffModel(String rainfallRunoffModelTypeName)
    {
        _rainfallRunoffModelTypeName = rainfallRunoffModelTypeName;
    }

    /**
     * @return Returns the rainfallRunoffModel.
     */
    public String getRainfallRunoffModelTypeName()
    {
        return _rainfallRunoffModelTypeName;
    }


	
} //end UnitHydrograph
