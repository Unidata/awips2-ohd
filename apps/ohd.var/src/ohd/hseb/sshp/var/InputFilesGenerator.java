package ohd.hseb.sshp.var;

import java.io.*;
import java.util.List;

import ohd.hseb.measurement.Measurement;
import ohd.hseb.measurement.RegularTimeSeries;
import ohd.hseb.model.MonthlyValues;
import ohd.hseb.model.UnitHydrograph;
import ohd.hseb.model.sacsma.SacSmaParameters;
import ohd.hseb.model.sacsma.SacSmaState;
import ohd.hseb.util.FileLogger;

import static ohd.hseb.util.TimeHelper.*;

/********************************************************************************************************
 * This class generates the var deck file, used as one of the input files for Var FORTRAN program. With 
 * Fortran program, this file is only needed if the two output files, "basinId_states_02_var" and 
 * "basinId_adj_states_02_var", doesn't exist -- the very first time of running Var. However, the Java 
 * program deletes the two output files in the end of each running. So this file is absolutely required 
 * every time when Var is executed.
 * This file extracts SacSma state variables and SacSma parameters information from database. peadj and pxadj 
 * are extracted from a text file previously saved. UHG information is extracted from database. 
 * @author lix
 *
 */
public class InputFilesGenerator 
{   
    private FileLogger _varControllerLogger = null;
    private final String _stdDeckLinesFile;
    private long _assimilationStartTimeLong = 0;
    private long _assimilationTargetTimeLong = 0;
    private int _futureHourCount = 0; 
    private String _basinId = null;
    private String _varInputDir = null;
    private String _varOutputDir = null;
    private String _segmentsFilePath = null;

    public InputFilesGenerator(FileLogger logger, String varInputDir, String varOutputDir, 
            String segmentsFilePath, String basinId, int futureHourCount) 
    {   
        _varControllerLogger = logger;
        _varInputDir = varInputDir;
        _varOutputDir = varOutputDir;
        _segmentsFilePath = segmentsFilePath;

        _basinId = basinId;
        _futureHourCount = futureHourCount;

        _stdDeckLinesFile = _varInputDir + "/param/deck_file_top_two_lines.txt";
    }
//  ----------------------------------------------------------------------------------------------------------------------------------
    public void setVarModelStartAndEndTimesLong(long assimilationStartTimeLong, long assimilationTargetTimeLong)
    {
        _assimilationStartTimeLong = assimilationStartTimeLong;
        _assimilationTargetTimeLong = assimilationTargetTimeLong;
    }
//  ----------------------------------------------------------------------------------------------------------------------------------

    /****************************************************************************************************
     * Generates the deck parameter file.
     *
     */
    public boolean generateDeckFile(String locationName, SacSmaState sacSmaState, 
            SacSmaParameters sacSmaParams, MonthlyValues monthlyValues,
            Double basinArea, UnitHydrograph uhg) 
    {
        PrintWriter writer = null;
        boolean isDeckFileCreationSuccessful = false;

        _varControllerLogger.log("Generating the Var parameter deck file for " +  _basinId);
        try
        {
            String deckFilePath = _varInputDir + "/param/" + _basinId + ".var_deck";
            writer = new PrintWriter(new FileOutputStream(deckFilePath), true);
            printDeckFileTopTwoLines(writer);
        }
        catch(Exception e)
        {
            _varControllerLogger.log(e.getMessage());
            return isDeckFileCreationSuccessful;
        }

        if(printSacSmaCards(writer, locationName,  sacSmaState, sacSmaParams,  monthlyValues))
        {
            if(printUnitHGCards(writer, uhg,  locationName,  basinArea))
            {
                _varControllerLogger.log("The input parameter deck file " + _basinId + ".var_deck has been generated by Java program.");
                isDeckFileCreationSuccessful = true;
            }
        }
        writer.close();
        return isDeckFileCreationSuccessful;

    }
//  ----------------------------------------------------------------------------------------------------------------------------------
    /******************************************************************************************
     * The top two lines of the original deck file generated by Var FORTRAN program contains
     * hard-coded information. They are identical for all the deck files. The first line contains 
     * 10 values which will be used in the execution of Var FORTRAN program. The second line 
     * contains 6 infinity large values. This method printDeckFileTopTwoLines() reads from a file 
     * containing the two lines and print them out.
     * @param 
     */
    private void printDeckFileTopTwoLines(PrintWriter writer) throws IOException
    {    
        String header = "DeckFileGenerator.printDeckFileTopTwoLines():";
        _varControllerLogger.log("In "+header);
        try
        {
            File file = new File(_stdDeckLinesFile);
            if ( ! file.exists())
            {
                createDeckFileTopTwoLines(file);
            }
            BufferedReader inputStream = new BufferedReader(new FileReader(file));
            writer.println(inputStream.readLine());  //first line
            writer.println(inputStream.readLine());  //second line
            inputStream.close();
        }
        catch(IOException e)
        {
            throw new IOException();
        }        
        return;
    }
    
    /**
     * 
     * @param file - the file to create
     * This routine creates a parameter file for var.
     * It is called only when the parameter file does not exist already.
     * This routine will make installation simpler and recovery from
     * accidental deletion of the file easy.
     * Once the file exists, the file can be edited, if desired.
     */
    private void createDeckFileTopTwoLines(File file)
    {
        String header = "InputFilesGenerator.createDeckFileTopTwoLines(): ";
        PrintWriter writer = null;

        try
        {
            writer = new PrintWriter(new FileWriter(file));
            writer.println("0.01  2.  0.5  1.0000  0.001  1  -10.  10.  15.  0.05");
            writer.println("  0.1E+22 0.1E+22 0.1E+22 0.1E+22 0.1E+22 0.1E+22");
            _varControllerLogger.log(header + " success");
        }
        catch (IOException e)
        {
            _varControllerLogger.log(header + " Failed to create deck file top two lines file");
        }
        finally
        {
            writer.close();
        }
    }
//  ----------------------------------------------------------------------------------------------------------------------------------

    /*****************************************************************************************
     * Based on SACRAMENTO SOIL MOISTURE ACCOUNTING OPERATION, print out cards from 1 to 6 for
     * the basin. All the information are extracted from Database 
     * 
     */
    private boolean printSacSmaCards(PrintWriter writer, String locationName, SacSmaState sacSmaState, 
            SacSmaParameters sacSmaParams, MonthlyValues monthlyValues)  //from Card 1 to 6
    {
        String header = "DeckFileGenerator.printSacSmaCards():";
        _varControllerLogger.log("In "+ header);
        boolean isPrintingSacSmaCardsSucceeded = false;
        //Card #1      
        writer.printf("%1$-20s" + space(8) +"%2$2d  %3$-8s %4$-4s" +space(7) +"%5$-8s %6$-4s\n",
                locationName, 
                1, _basinId, "MAPX", _basinId, "INFW");

        //Card #2
        writer.printf(space(18) + "%1$2d" + "  %2$-8s" + "  %3$-8s" + " %4$-4s" + space(5) + "   %5$2d" + "   %6$2d     \n",
                0, _basinId, _basinId, "SUMS", 24, 24);
        //%4: data time interval of the runoff components time series (default is 24)
        //%5: data time interval of the soil moisture storage time series (defult is 24)

        //Card #3
        //sacSmaParams for both card #3 and #4
        writer.printf(space(20) + "%1$5.3f%2$5.3f%3$5.1f%4$5.1f%5$5.3f%6$5.3f%7$5.3f%8$5.3f%9$5d%10$5.3f\n", 
                sacSmaParams.getPxadj(),
                sacSmaParams.getPeadj(),
                sacSmaParams.getUztwm(),
                sacSmaParams.getUzfwm(),
                sacSmaParams.getUzk(),
                sacSmaParams.getPctim(),
                sacSmaParams.getAdimp(),
                sacSmaParams.getRiva(),
                0,     //I5  diurnal ET variation option (default is uniform distribution of daily ET-demand); enter value greater than zero to use diurnal variation.
                sacSmaParams.getEfc());

        //Card #4
        writer.printf(space(20) + "%1$5.1f%2$5.2f%3$5.1f%4$5.1f%5$5.1f%6$5.3f%7$5.3f%8$5.3f%9$5.3f%10$5.3f\n", 
                sacSmaParams.getZperc(),
                sacSmaParams.getRexp(),
                sacSmaParams.getLztwm(),
                sacSmaParams.getLzfsm(),
                sacSmaParams.getLzfpm(),
                sacSmaParams.getLzsk(),
                sacSmaParams.getLzpk(),
                sacSmaParams.getPfree(),
                sacSmaParams.getRserv(),
                sacSmaParams.getSide());

        //Card #5: 12 values for ET-demand or PE-adjustment factor, locations are: 21-24,25-28,29-32,33-36,37-40,41-44,45-48,49-52,53-56,57-60,61-64,65-68

        double[] recentMonthValuesArray = monthlyValues.getValueArray(); 
        writer.printf(space(20));
        for (int i = 0; i <= 11; i++)
        {
            writer.printf("%4.2f", recentMonthValuesArray[i]);
        }
        writer.printf("\n");

        //Card #6
        writer.printf(space(20) + "%1$5.1f%2$5.1f%3$5.1f%4$5.1f%5$5.1f%6$5.1f    %7$1d\n", 
                sacSmaState.getUztwc(),
                sacSmaState.getUzfwc(),
                sacSmaState.getLztwc(),
                sacSmaState.getLzfsc(),
                sacSmaState.getLzfpc(),
                sacSmaState.getAdimc(),
                1);
        isPrintingSacSmaCardsSucceeded = true;
        return isPrintingSacSmaCardsSucceeded;
    } //close method
//  ----------------------------------------------------------------------------------------------------------------------------------

    /*****************************************************************************************
     * Based on the UNIT HYDROGRAPH OPERATION, print out Card #1, #3, #4. The Unit Hydrograph 
     * information of basin_id is extracted from Database. It is SAC-SMA model.
     */
    private boolean printUnitHGCards(PrintWriter writer, UnitHydrograph unitHG, String locationName, Double basinArea)
    {
        boolean didPrintingUnitHGCardsSucceed = false;

        String header = "DeckFileGenerator.printUnitHGCards():";
        _varControllerLogger.log("In "+header);

        List measurementList  = unitHG.getMeasurementList();

        //Card# 1
        writer.printf("%1$-20s     %2$10.1f  %3$3d  %4$8s %5$-4s%6$10.3f\n", 
                locationName,
                basinArea,
                measurementList.size(),
                "CARRY",
                "ENGL",
                0.0); //constant baseflow to be added to computed instantaneous discharges(0.0 = currently no constant baseflow)

        //Card# 3 -- #2 is skipped because no '1' is entered at postion 69 in Card #1
        writer.printf("  %1$-8s %2$-4s   %3$2d  %4$-8s %5$-4s   %6$2d\n", 
                _basinId,
                "INFW",
                1,    //data time interval of runoff time series(HR) (computational time interval of the Operation)
                _basinId,
                "SQIN",
                1);   //data time interval of discharge time series(HR) (spacing of the unit hydrograph ordinates)

        //Card #4 -- Unit hydrograph ordinates: each row has 7 columns, locations: 4-10,14-20,24-30,...,54-60,64-70 
        int totalNumberOfColumns = 7;// totally 7 columns in one row

        didPrintingUnitHGCardsSucceed = printUHGOrdinates(writer, totalNumberOfColumns, measurementList);
        return didPrintingUnitHGCardsSucceed ;
    }
//  ----------------------------------------------------------------------------------------------------------------------------------
    private boolean printUHGOrdinates(PrintWriter writer, int totalNumberOfColumns, List measurementList)
    {
        boolean didPrintingUnitHGCardsSucceed = false;

        //Card #4 -- Unit hydrograph ordinates: each row has 7 columns, locations: 4-10,14-20,24-30,...,54-60,64-70
        int totalNumberOfRows = (measurementList.size()) / (totalNumberOfColumns);
        boolean isIndexValid = true;

        for (int row = 0; row <= totalNumberOfRows; row++)  //counting the rows, starting from 0
        {
            for (int column = 0; column < totalNumberOfColumns; column++) //counting the columns, from 0 to 6
            {
                int index = row * totalNumberOfColumns + column; // index to use in the measurement list
                if (index > (measurementList.size()-1)) //for the last row, check to make sure index not out of range
                {
                    isIndexValid = false;
                    writer.printf("\n"); //finish last row
                    break;
                }
                writer.printf("%10.2f", ((Measurement)(measurementList.get(index))).getValue());
            } //end of inner loop (for columns)

            if( ! isIndexValid )
            {
                break;                    
            }
            writer.printf("\n");  //move to next row
        } //outer loop (for rows)
        didPrintingUnitHGCardsSucceed = true;
        return didPrintingUnitHGCardsSucceed;
    }
//  ----------------------------------------------------------------------------------------------------------------------------------
    /*****************************************************************************************
     * A helper method for formatting.
     * @param num
     * @return
     */
    private String space(int num)
    {
        StringBuffer bf = new StringBuffer(72);
        for (int i = 1; i <= num; i++)
        {
            bf.append(' ');
        }
        return bf.toString();
    }
//  ----------------------------------------------------------------------------------------------------------------------------------

    /*********************************************************************************************************************
     * generate precip & discharge files like BLUO2.mapx_ts_var_dat or BLUO2.qin01_ts_var_dat
     * 
     */

    public boolean generateObsInputFiles(RegularTimeSeries precipRTS, RegularTimeSeries dischargeRTS)
    {
        boolean isObsInputFileCreationSuccessful = false;
        String header = "ObsInputFileGenerator.generateObsInputFiles():";
        _varControllerLogger.log("In "+ header);

        String precipFile = _varOutputDir +"/"+_basinId + ".mapx_ts_var_dat";
        String dischargeFile = _varOutputDir + "/"+_basinId + ".qin01_ts_var_dat";

        //generate precipitation file "basinId.mapx_ts_var_dat" file
        if(generateFile(precipFile, precipRTS))
        {
            //generate discharge file "basinId.qin01_ts_var_dat" file
            if(generateFile(dischargeFile, dischargeRTS))
            {
                isObsInputFileCreationSuccessful = true;
            }
            else
            {
                _varControllerLogger.log("Failed In Creating :"+ dischargeFile );    
            }
        }
        else
        {
            _varControllerLogger.log("Failed In Creating :"+ precipFile );    
        }
        return isObsInputFileCreationSuccessful;
    }
//  ----------------------------------------------------------------------------------------------------------------------------------

    private int getPastHourlyValueCount()
    {
        long elapsedTimeInMillis =  _assimilationTargetTimeLong - _assimilationStartTimeLong ;
        int elapsedTimeInHours = (int)(elapsedTimeInMillis / MILLIS_PER_HOUR) + 1; 
        return  elapsedTimeInHours ;
    }
//  ----------------------------------------------------------------------------------------------------------------------------------

    // Count of the past & forecast values that is written in the file
    private int getTotalHourlyValueCount()
    {
        return getPastHourlyValueCount() + _futureHourCount; 
    }
//  ----------------------------------------------------------------------------------------------------------------------------------

    /***************************************************************************************************************************
     * Generate input files, like BLUO2.mapx_ts_var_dat or BLUO2.qin01_ts_var_dat. For precipiation, unit: cms; inflow, unit: mm.
     * First line is always:
     * " Z    240  360" -- means UTC time zone, backward data assimilation 240 hours(24 days), total data hours are 360 hours
     * (forecasting 120 hours -- 5 days).
     * From 2nd line to the end of file:
     * year month day hour obs(precip with unit of mm, converted from database inch value; 
     *                         discharge with unit of cms, converted from database cfs value.)
     * The time period specified in the two files determines the time period Fortran Var script will compute.
     * In the forecasting period, the discharge is set to -1, the precip is set to 0.
     */
    private boolean generateFile(String fileName, RegularTimeSeries rts) 
    {
        boolean isObsInputFileCreationSuccessful = false;

        String header = "ObsInputFileGenerator.generateFile():";
        _varControllerLogger.log("In "+ header);

        _varControllerLogger.log("\nGenerating the file [" + fileName +"]");

        
     //   System.out.println("\nGenerating the file [" + fileName +"]");
        
        PrintWriter outputStream = null;
        try
        {
            outputStream = new PrintWriter(new FileOutputStream(fileName));

            /*first line in the file lid.qin01_ts_var_dat,  going back 10 days(240 rows, 1 hour interval), 
              total 360 rows ( 5 days ahead prediction, 120 rows)*/
            outputStream.println(" Z    " + getPastHourlyValueCount() + "  " + getTotalHourlyValueCount());   

            for (int i = 0; i < rts.getMeasurementCount(); i++)
            {
                long time = rts.getMeasurementTimeByIndex(i);
                String[] arrayYearMonDayHour = VarHelper.getArrayYearMonthDayHour24HConventionFromLongTime(time);

                double value =  rts.getMeasurementByIndex(i).getValue();
                
           //     System.out.println(header + "time = " + DbTimeHelper.getDateTimeStringFromLongTime(time) + " value = " + value );
                
                outputStream.printf("%1$13s   %2$10s   %3$10s   %4$10s   %5$9.6f\n",
                        arrayYearMonDayHour[0],   //year 
                        arrayYearMonDayHour[1],   //month
                        arrayYearMonDayHour[2],   //day
                        arrayYearMonDayHour[3],   //hour
                        value); // all RTS has to be in correct unit

            } //close for loop       
            _varControllerLogger.log("The input file [" + fileName + "] has been generated by Java program.");

            isObsInputFileCreationSuccessful = true;
        }
        catch (IOException e)
        {
            _varControllerLogger.log("IO exception with file " + fileName + " " + e.getMessage());
            isObsInputFileCreationSuccessful = false;
        }
        finally
        {
            if (outputStream != null)
            {
                outputStream.close();
            }
        }

        return isObsInputFileCreationSuccessful;
    }
//  ----------------------------------------------------------------------------------------------------------------------------------

    //generate the file "list_of_segments" -- it is only one line
    public boolean generateSegmentsFile()
    {
        int qpfHourCount = 0;
        boolean success = false;
        try
        {
            PrintWriter outputStream = new PrintWriter(new FileOutputStream(_segmentsFilePath));
            outputStream.println(_basinId + " " + qpfHourCount);
            outputStream.close();
            success = true;
        }
        catch(FileNotFoundException e)
        {
           _varControllerLogger.log(_segmentsFilePath + " is not found or could not be opened.");
        }
        return success;
    }
//  ----------------------------------------------------------------------------------------------------------------------------------
} //close class
